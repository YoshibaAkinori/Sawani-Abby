// app/api/bookings/route.js
import { NextResponse } from 'next/server';
import { getConnection } from '../../../lib/db';

// 予約一覧取得
export async function GET(request) {
  try {
    const pool = await getConnection();
    const { searchParams } = new URL(request.url);
    const date = searchParams.get('date');
    const staffId = searchParams.get('staffId');
    const customerId = searchParams.get('customerId');
    const bookingId = searchParams.get('id');

    let query = `
      SELECT 
        b.booking_id,
        b.customer_id,
        b.staff_id,
        b.service_id,
        b.customer_ticket_id,
        b.coupon_id,
        b.limited_offer_id,
        b.date,
        b.start_time,
        b.end_time,
        b.bed_id,
        b.type,
        b.status,
        b.notes,
        b.created_at,
        c.last_name,
        c.first_name,
        s.name as staff_name,
        s.color as staff_color,
        sv_direct.name as direct_service_name,
        sv_direct.category as direct_service_category,
        tp.name as ticket_plan_name,
        sv_ticket.category as ticket_service_category,
        cp.name as coupon_name,
        cp.description as coupon_description,
        cp.total_price as coupon_price,
        lo.name as limited_offer_name,
        lo.description as limited_offer_description,
        lo.special_price as limited_offer_price,
        lo.total_sessions as limited_offer_sessions,
        COALESCE(cp.name, lo.name, tp.name, sv_direct.name) as service_name,
        CASE
          WHEN cp.coupon_id IS NOT NULL THEN 'クーポン'
          WHEN lo.offer_id IS NOT NULL THEN '期間限定'
          ELSE COALESCE(sv_direct.category, sv_ticket.category)
        END as service_category
      FROM bookings b
      LEFT JOIN customers c ON b.customer_id = c.customer_id
      LEFT JOIN staff s ON b.staff_id = s.staff_id
      LEFT JOIN services sv_direct ON b.service_id = sv_direct.service_id
      LEFT JOIN customer_tickets ct ON b.customer_ticket_id = ct.customer_ticket_id
      LEFT JOIN ticket_plans tp ON ct.plan_id = tp.plan_id
      LEFT JOIN services sv_ticket ON tp.service_id = sv_ticket.service_id
      LEFT JOIN coupons cp ON b.coupon_id = cp.coupon_id
      LEFT JOIN limited_offers lo ON b.limited_offer_id = lo.offer_id
      WHERE 1=1
      AND b.status NOT IN ('cancelled', 'no_show')
    `;

    const params = [];

    if (bookingId) {
      query += ' AND b.booking_id = ?';
      params.push(bookingId);
    }

    if (date) {
      query += ' AND b.date = ?';
      params.push(date);
    }

    if (staffId) {
      query += ' AND b.staff_id = ?';
      params.push(staffId);
    }

    if (customerId) {
      query += ' AND b.customer_id = ?';
      params.push(customerId);
    }

    query += ' ORDER BY b.date, b.start_time';

    const [rows] = await pool.execute(query, params);

    for (let booking of rows) {
      const [options] = await pool.execute(
        `SELECT 
          bo.booking_option_id,
          o.option_id,
          o.name as option_name,
          o.category as option_category,
          o.price,
          o.duration_minutes
        FROM booking_options bo
        JOIN options o ON bo.option_id = o.option_id
        WHERE bo.booking_id = ?`,
        [booking.booking_id]
      );
      booking.options = options;

      const [tickets] = await pool.execute(
        `SELECT 
          bt.booking_ticket_id,
          bt.customer_ticket_id,
          ct.customer_id,
          tp.name as plan_name,
          tp.total_sessions,
          ct.sessions_remaining,
          ct.expiry_date,
          s.name as service_name,
          s.category as service_category,
          s.duration_minutes,
          s.price
        FROM booking_tickets bt
        JOIN customer_tickets ct ON bt.customer_ticket_id = ct.customer_ticket_id
        JOIN ticket_plans tp ON ct.plan_id = tp.plan_id
        JOIN services s ON tp.service_id = s.service_id
        WHERE bt.booking_id = ?`,
        [booking.booking_id]
      );
      booking.tickets = tickets;

      const [limitedOffers] = await pool.execute(
        `SELECT 
          blo.booking_limited_offer_id,
          blo.offer_id,
          lo.offer_type,
          lo.name,
          lo.description,
          lo.category,
          lo.duration_minutes,
          lo.special_price,
          lo.total_sessions
        FROM booking_limited_offers blo
        JOIN limited_offers lo ON blo.offer_id = lo.offer_id
        WHERE blo.booking_id = ?`,
        [booking.booking_id]
      );
      booking.limited_offers = limitedOffers;

      if (tickets.length > 0) {
        const ticketNames = tickets.map(t => t.plan_name).join(' + ');
        booking.service_name = ticketNames;
        booking.service_category = '回数券';
      } else if (limitedOffers.length > 0) {
        const offerNames = limitedOffers.map(o => o.name).join(' + ');
        booking.service_name = offerNames;
        booking.service_category = '期間限定';
      }
    }

    return NextResponse.json({
      success: true,
      data: rows
    });
  } catch (error) {
    console.error('予約取得エラー:', error);
    return NextResponse.json(
      { success: false, error: 'データベースエラー' },
      { status: 500 }
    );
  }
}

// 予約・予定新規登録
export async function POST(request) {
  const pool = await getConnection();
  const connection = await pool.getConnection();

  try {
    const body = await request.json();

    const {
      customer_id,
      staff_id,
      service_id,
      customer_ticket_ids,
      coupon_id,
      limited_offer_ids,
      date,
      start_time,
      end_time,
      bed_id,
      type = 'booking',
      status = 'confirmed',
      notes = '',
      option_ids = []
    } = body;

    if (type === 'schedule') {
      if (!staff_id || !date || !start_time || !end_time) {
        return NextResponse.json(
          { success: false, error: 'スタッフと日時を入力してください' },
          { status: 400 }
        );
      }
    } else {
      if (!staff_id || !date || !start_time || !end_time) {
        return NextResponse.json(
          { success: false, error: '必須項目を入力してください' },
          { status: 400 }
        );
      }

      if (!customer_id && !body.last_name && !body.first_name) {
        return NextResponse.json(
          { success: false, error: '顧客情報を入力してください' },
          { status: 400 }
        );
      }

      const hasTickets = customer_ticket_ids && customer_ticket_ids.length > 0;
      const hasLimitedOffers = limited_offer_ids && limited_offer_ids.length > 0;

      if (!service_id && !hasTickets && !coupon_id && !hasLimitedOffers) {
        return NextResponse.json(
          { success: false, error: '施術メニューを選択してください' },
          { status: 400 }
        );
      }
    }

    await connection.beginTransaction();

    let finalCustomerId = customer_id;

    if (type === 'booking' && !customer_id && body.last_name && body.first_name) {
      await connection.execute(
        `INSERT INTO customers (
          customer_id,
          last_name,
          first_name,
          last_name_kana,
          first_name_kana,
          phone_number,
          email,
          birth_date,
          gender
        ) VALUES (UUID(), ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          body.last_name,
          body.first_name,
          body.last_name_kana || '',
          body.first_name_kana || '',
          body.phone_number || '',
          body.email || '',
          body.birth_date || null,
          body.gender || 'not_specified'
        ]
      );

      const [customerRow] = await connection.execute(
        'SELECT customer_id FROM customers WHERE phone_number = ? ORDER BY created_at DESC LIMIT 1',
        [body.phone_number]
      );
      finalCustomerId = customerRow[0].customer_id;
    }

    await connection.execute(
      `INSERT INTO bookings (
        booking_id,
        customer_id,
        staff_id,
        service_id,
        customer_ticket_id,
        coupon_id,
        limited_offer_id,
        date,
        start_time,
        end_time,
        bed_id,
        type,
        status,
        notes
      ) VALUES (UUID(), ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        finalCustomerId,
        staff_id,
        service_id ?? null,
        customer_ticket_ids && customer_ticket_ids.length > 0 ? customer_ticket_ids[0] : null,
        coupon_id ?? null,
        limited_offer_ids && limited_offer_ids.length > 0 ? limited_offer_ids[0] : null,
        date,
        start_time,
        end_time,
        bed_id ?? null,
        type,
        status,
        notes
      ]
    );

    const [bookingRow] = await connection.execute(
      `SELECT booking_id FROM bookings 
       WHERE staff_id = ? AND date = ? AND start_time = ? 
       ORDER BY created_at DESC LIMIT 1`,
      [staff_id, date, start_time]
    );
    const bookingId = bookingRow[0].booking_id;

    if (customer_ticket_ids && customer_ticket_ids.length > 0) {
      for (const ticketId of customer_ticket_ids) {
        await connection.execute(
          `INSERT INTO booking_tickets (booking_id, customer_ticket_id)
           VALUES (?, ?)`,
          [bookingId, ticketId]
        );
      }
    }

    if (limited_offer_ids && limited_offer_ids.length > 0) {
      for (const offerId of limited_offer_ids) {
        await connection.execute(
          `INSERT INTO booking_limited_offers (
            booking_limited_offer_id,
            booking_id,
            offer_id
          ) VALUES (UUID(), ?, ?)`,
          [bookingId, offerId]
        );
      }
    }

    if (type === 'booking' && option_ids && option_ids.length > 0) {
      for (const optionId of option_ids) {
        await connection.execute(
          `INSERT INTO booking_options (
            booking_option_id,
            booking_id,
            option_id
          ) VALUES (UUID(), ?, ?)`,
          [bookingId, optionId]
        );
      }
    }

    await connection.commit();

    return NextResponse.json({
      success: true,
      message: type === 'schedule' ? '予定を登録しました' : '予約を登録しました',
      data: {
        booking_id: bookingId,
        customer_id: finalCustomerId
      }
    });
  } catch (error) {
    await connection.rollback();
    console.error('登録エラー:', error);
    return NextResponse.json(
      { success: false, error: 'データベースエラー: ' + error.message },
      { status: 500 }
    );
  } finally {
    if (connection) {
      connection.release();
    }
  }
}

// 予約更新
export async function PUT(request) {
  const pool = await getConnection();
  const connection = await pool.getConnection();

  try {
    const body = await request.json();

    const {
      booking_id,
      date,
      start_time,
      end_time,
      staff_id,
      bed_id,
      status,
      notes
    } = body;

    if (!booking_id) {
      return NextResponse.json(
        { success: false, error: '予約IDが必要です' },
        { status: 400 }
      );
    }

    await connection.beginTransaction();

    const [beforeData] = await connection.execute(
      'SELECT * FROM bookings WHERE booking_id = ?',
      [booking_id]
    );

    if (beforeData.length === 0) {
      return NextResponse.json(
        { success: false, error: '予約が見つかりません' },
        { status: 404 }
      );
    }

    const before = beforeData[0];

    await connection.execute(
      `UPDATE bookings 
       SET date = ?,
           start_time = ?,
           end_time = ?,
           staff_id = ?,
           bed_id = ?,
           status = ?,
           notes = ?
       WHERE booking_id = ?`,
      [date, start_time, end_time, staff_id, bed_id, status, notes, booking_id]
    );

    const changes = {
      before: {
        date: before.date,
        start_time: before.start_time,
        end_time: before.end_time,
        staff_id: before.staff_id,
        bed_id: before.bed_id,
        status: before.status,
        notes: before.notes
      },
      after: {
        date,
        start_time,
        end_time,
        staff_id,
        bed_id,
        status,
        notes
      }
    };

    await connection.execute(
      `INSERT INTO booking_history (
        history_id,
        booking_id,
        change_type,
        details
      ) VALUES (UUID(), ?, 'update', ?)`,
      [booking_id, JSON.stringify(changes)]
    );

    await connection.commit();

    return NextResponse.json({
      success: true,
      message: '予約を更新しました'
    });
  } catch (error) {
    await connection.rollback();
    console.error('予約更新エラー:', error);
    return NextResponse.json(
      { success: false, error: 'データベースエラー' },
      { status: 500 }
    );
  } finally {
    if (connection) {
      connection.release();
    }
  }
}

// 予約削除/キャンセル
export async function DELETE(request) {
  const pool = await getConnection();
  const connection = await pool.getConnection();

  try {
    const { searchParams } = new URL(request.url);
    const bookingId = searchParams.get('id');
    const cancelType = searchParams.get('cancelType');

    if (!bookingId) {
      return NextResponse.json(
        { success: false, error: '予約IDが必要です' },
        { status: 400 }
      );
    }

    await connection.beginTransaction();

    const [booking] = await connection.execute(
      'SELECT * FROM bookings WHERE booking_id = ?',
      [bookingId]
    );

    if (booking.length === 0) {
      return NextResponse.json(
        { success: false, error: '予約が見つかりません' },
        { status: 404 }
      );
    }

    const bookingData = booking[0];

    const cancelDetails = {
      ...bookingData,
      cancel_type: cancelType || 'unknown',
      cancelled_at: new Date().toISOString()
    };

    await connection.execute(
      `INSERT INTO booking_history (
        history_id,
        booking_id,
        change_type,
        details
      ) VALUES (UUID(), ?, ?, ?)`,
      [
        bookingId,
        cancelType === 'no_contact' ? 'no_show' : 'cancel',
        JSON.stringify(cancelDetails)
      ]
    );

    const cancelStatus = cancelType === 'no_contact' ? 'no_show' : 'cancelled';

    await connection.execute(
      `UPDATE bookings SET status = ? WHERE booking_id = ?`,
      [cancelStatus, bookingId]
    );

    await connection.commit();

    const message = cancelType === 'no_contact'
      ? '予約をキャンセルしました(無断キャンセル)'
      : '予約をキャンセルしました';

    return NextResponse.json({
      success: true,
      message
    });
  } catch (error) {
    await connection.rollback();
    console.error('予約削除エラー:', error);
    return NextResponse.json(
      { success: false, error: 'データベースエラー' },
      { status: 500 }
    );
  } finally {
    if (connection) {
      connection.release();
    }
  }
}